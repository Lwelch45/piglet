// ----------------- header declaration ----------------- 
init_code(includes) ::= <<
import org.apache.flink.streaming.api.scala._
import java.util.concurrent.TimeUnit

<\n>
>>
// ----------------- BEGIN of code building and initializing the query --------
begin_query(name) ::= <<
object <name> {
    def main(args: Array[String]) {
        val env = StreamExecutionEnvironment.getExecutionEnvironment<\n>
>>

// ----------------- LOAD text file -------------------------------------------
loader(out,file,pfunc,rdffunc,params,schema) ::=<<
<if (pfunc)><pigstorage(out=out,file=file,del=params,schema=schema)>
<elseif (rdffunc)><rdfstorage(out=out,file=file)>
<else> 
        val <out> = env.readTextFile("<file>")
<endif>
>>

pigstorage(out,file,del,schema) ::=<<
        val <out> = env.readTextFile("<file>").map(line => line.split(<del>)).map(a => (a(0)<schema:{ e | ,a(<e>)}>))
>>

rdfstorage(out,file) ::=<<
        val pattern = "([^\"]\\S*|\".+?\")\\s*".r
        val <out> = env.readTextFile("<file>").map(line => pattern.findAllIn(line).map(_.trim).toArray.slice(0,3)).map(a => (a(0),a(1),a(2)))
>>


// ------------------ DUMP Results --------------------------------------------
dump(in) ::=<<
        <in>.print
>>

// ------------------ STORE Results on Disk -----------------------------------
store(in,file) ::=<<
        <in>.writeAsText("<file>")
<!       
        if (<in>.getJavaStream.getType.isTupleType) <in>.writeAsCsv("<file>")
        else <in>.writeAsText("<file>")
!>
>>

// ------------------ FILTER for a Predicate ----------------------------------
filter(out,in,pred) ::=<<
        val <out> = <in>.filter(t => {<pred>})
>>

// ------------------ Executes an expression FOR EACH input element -----------
foreach(out,in,expr) ::=<<
        val <out> = <in>.map(t => <expr>)
>>

// ------------------ GROUPS elements on an expression ------------------------
groupBy(out,in,expr) ::=<<
<if (expr)>
        val <out> = <in>.groupBy(<expr>)
<else>
        val <out> = <in>
<endif>
>>

// ------------------ Outputs only distinct values ----------------------------
distinct(out,in) ::=<<
        val <out> = <in>
>>

// ------------------ Outputs only num records --------------------------------
limit(out,in,num) ::=<<
        val <out> = <in>.window(Count.of(<num>)).every(Time.of(5, TimeUnit.SECONDS))
>>

// ------------------ Joins two streams on the specified keys -----------------
join(out,rel1,key1,rel2,key2,lsize,rsize) ::=<<
        val <out> = <rel1>.join(<rel2>).onWindow(5, TimeUnit.SECONDS).where(<key1>).equalTo(<key2>){ 
            (l,r) => (l._1<lsize:{ l | ,l._<l>}><rsize:{ r | ,r._<r>}>) 
        }
>>

// ------------------ UNIONs multiple streams to one --------------------------
union(out,in,others) ::=<<
        val <out> = <in>.merge(<others>)
>>


// ----------------- END of the code implementing the query -------------------
end_query(name) ::= <<
        env.execute("<name>")
    }
}
>>
